./game/game.c:
#include "game.h"

void init_field(Cell** field) {
    for(unsigned char init_row = 0; 
		      init_row < 10; 
		      init_row++)
	for(unsigned char init_col = 0; 
			  init_col < 10; 
			  init_col++) {
	    field[init_row][init_col].row     = init_row;
	    field[init_row][init_col].col     = init_col;
	    field[init_row][init_col].ship    = NULL;
	    field[init_row][init_col].status  = WATER;
	}
}

Ship* create_ship(int type_ship) {
    int flag_error = SUCCESS;

    Ship* ship = malloc(sizeof(Ship));
    if(!ship) {
	flag_error = ERR_ALLOCATION;
	log_err(flag_error);
    }

    if(!flag_error) {
	switch(type_ship) {
	    case BATTLESHIP:
		ship->length = 4;
		ship->hp     = 4;
		break;
	    case CRUISER:
		ship->length = 3;
		ship->hp     = 3;
		break;
	    case DESTROYER:
		ship->length = 2;
		ship->hp     = 2;
		break;
	    case BOAT:
		ship->length = 1;
		ship->hp     = 1;
		break;
	}
    }

    return ship;
}

void init_game(Game* settings) {
    settings->p1_field = malloc(FIELD_SIZE * sizeof(Cell*));
    for (int cell = 0; cell < FIELD_SIZE; cell++)
    	settings->p1_field[cell] = malloc(FIELD_SIZE * sizeof(Cell));
    init_field(settings->p1_field);

    settings->p2_field = malloc(FIELD_SIZE * sizeof(Cell*));
    for (int i = 0; i < FIELD_SIZE; i++)
    	settings->p2_field[i] = malloc(FIELD_SIZE * sizeof(Cell));
    init_field(settings->p2_field);

    settings->count_p1_ships  = 0;  
    settings->p1_ships = malloc(COUNT_SHIPS * sizeof(Ship*));
    
    settings->count_p2_ships  = 0;
    settings->p2_ships = malloc(COUNT_SHIPS * sizeof(Ship*));

    int ship_types[] = { BATTLESHIP, 
	    		 CRUISER, CRUISER, 
			 DESTROYER, DESTROYER, DESTROYER, 
			 BOAT, BOAT, BOAT, BOAT };
    for (int ship = 0; ship < COUNT_SHIPS; ship++) {
    	settings->p1_ships[ship] = create_ship(ship_types[ship]);
    	settings->p2_ships[ship] = create_ship(ship_types[ship]);
    	settings->p1_ships[ship]->is_placed = false;
    	settings->p2_ships[ship]->is_placed = false;
    }

    settings->active_ship = 0;
    settings->game_mode   = PLACEMENT_MODE;
    settings->game_screen = PLAYER1_SCREEN;
}

void free_field(Cell** field) {
    if(field) {
        for (int cell = 0; 
		 cell < FIELD_SIZE; 
		 cell++) {
            free(field[cell]); 
        }
        free(field); 
	field = NULL;
    }
}

void free_ships(Ship** ships) {
    if (ships) {
        for (unsigned char ship = 0; 
			   ship < COUNT_SHIPS; 
			   ship++) { 
            if (ships[ship]) {
                free(ships[ship]);
                ships[ship] = NULL;
            }
        }
        free(ships); 
        ships = NULL;
    }
}

void game_over(Game* settings) {
    free_field(settings->p1_field);
    free_field(settings->p2_field);

    free_ships(settings->p1_ships);
    free_ships(settings->p2_ships);

    settings->count_p1_ships = 0;
    settings->count_p2_ships = 0;
}

int attack_ship(Game* settings,
		Cell* def_cell) {
    int flag_error = ERR_RE_ATTACK;
    if(def_cell->status == WATER) {
	def_cell->status = MISS;
    	flag_error = SUCCESS;
    }
    
    if(def_cell->status == SHIP) {
	def_cell->ship->hp--;
	if(def_cell->ship->hp == 0)
	    kill_ship(settings,
		      def_cell->ship);
	else
	    def_cell->status = HIT;
    }

    return flag_error;
}

void kill_ship(Game* settings,
	       Ship* ship) {
    for(size_t cell = 0; 
	       cell < ship->length;
	       cell++) {
	ship->address[cell]->status = KILL;
    }

    if(settings->game_screen == PLAYER1_SCREEN)
	settings->count_p2_ships--;
    else
	settings->count_p1_ships--;
}

int place_ship(Cell** field,
	       Ship*  ship, 
	       Cell*  def_cell,
	       int    direction) {
    int flag_error = SUCCESS;
    
    switch(direction) {
	case VERT:
	    flag_error = filling_cells_vert(field, 
			    	 	    ship, 
					    def_cell);
	    log_err(flag_error);
	    break;
	case HOR:
	    flag_error = filling_cells_hor(field, 
			      		   ship, 
			      	 	   def_cell);
	    log_err(flag_error);
	    break;
	default:
	    break;
    }

    return flag_error;
}

int is_free_space(Cell** field,
		  Ship*  def_ship,
		  Cell*  def_cell,
		  int    direction) {
    int flag_error = SUCCESS;

    int row = def_cell->row;
    int col = def_cell->col;

    for (int r = row - 1; 
	     r <= row + 1 && !flag_error; 
	     r++) {
        for (int c = col - 1; 
		 c <= col + 1 && !flag_error; 
		 c++) {
            if (r >= 0 && 
		r < FIELD_SIZE && 
		c >= 0 && 
		c < FIELD_SIZE) {
                if (field[r][c].ship != NULL && 
		    !(r == row && c == col)) {
                    flag_error = ERR_OCC_CELL;
                }
            }
        }
    }

    unsigned char count_len = def_ship->length;
    if(direction == VERT) {
    	if(count_len <= 
           def_cell->row + 1) {
	    for(; count_len > 0 && !flag_error;
		  row--) {
	        if(field[row][def_cell->col].ship)
	    	    flag_error = ERR_OCC_CELL;
		else
		    count_len--;
	    }
	} else
	    flag_error = ERR_NO_SPACE;
    }
    if(direction == HOR) {
	if(count_len <= 
       	   10 - def_cell->col) {
	    for(; count_len > 0 && !flag_error;
		  col++) {
	    	if(field[def_cell->row][col].ship)
	    	    flag_error = ERR_OCC_CELL;
	        else	
		    count_len--;
	    }
	} else
	    flag_error = ERR_NO_SPACE;
    }

    return flag_error;
}

int filling_cells_vert(Cell** field,
		       Ship*  def_ship,
		       Cell*  def_cell) {
    int flag_error = SUCCESS;

    
    unsigned char count_len = def_ship->length;
    
    flag_error = is_free_space(field,
		      	       def_ship,
		      	       def_cell,
		      	       VERT);
    for(int row = def_cell->row; 
	    count_len > 0 && !flag_error; 
            row--) {
	field[row][def_cell->col].ship   = def_ship; 
	field[row][def_cell->col].status = SHIP; 
	def_ship->address[count_len - 1] = &field[row][def_cell->col];
	count_len--;
    } 

    return flag_error;
}

int filling_cells_hor(Cell** field,
		      Ship*  def_ship,
		      Cell*  def_cell) {
    int flag_error = SUCCESS;

    unsigned char count_len = def_ship->length;
    
    flag_error = is_free_space(field,
		      	       def_ship,
		      	       def_cell,
		      	       HOR);
    for(int col = def_cell->col; 
	    count_len > 0 && !flag_error;
	    col++) {
	field[def_cell->row][col].ship   = def_ship;
	field[def_cell->row][col].status = SHIP;
	def_ship->address[count_len - 1] = &field[def_cell->row][col];
	count_len--;
    } 

    return flag_error;
}

void log_err(int flag_error) {
    FILE* log_file = fopen("../log_file.txt", "a");
    
    
    time_t current_time = time(NULL);
    struct tm *time_info;
    char   time_str[100];
    time_info = localtime(&current_time);
    strftime(time_str, 
	     sizeof(time_str), 
	     "%Y-%m-%d %H:%M:%S", time_info);

    if(!log_file) {
	flag_error = ERR_ALLOCATION;
    	printf("Ошибка открытия файла! - %s\n", time_str);
    } else {
    	switch(flag_error) {
	    case ERR_ALLOCATION:
	    	fprintf(log_file, 
		        "Ошибка выделения памяти! - %s\n",  time_str);
	    	break;
	    case ERR_NO_SPACE:
	    	fprintf(log_file, 
		        "Выход за пределы массива! - %s\n", time_str);
	    	break;
	    case ERR_OCC_CELL:
	    	fprintf(log_file, 
		        "Клетка занята! - %s\n", 	    time_str);
	    	break;
	    default:
	    	break;
    	}
    }

    fclose(log_file);
}

./game/game.h:
#ifndef GAME_H
#define GAME_H

#include "../include/config.h"

typedef struct Cell Cell;

typedef struct {
    Cell* 	  address[4];
    unsigned char length;
    unsigned char hp;
    bool 	  is_placed;
} Ship;

typedef struct Cell {
    Ship* 	  ship;
    unsigned char row;
    unsigned char col;
    	     char status;
} Cell;

typedef struct {
    Cell**        p1_field;
    Cell**	  p2_field;
    Ship** 		p1_ships;
    unsigned char count_p1_ships;
    Ship** 		p2_ships;
    unsigned char count_p2_ships;
    char   	  game_mode;
    char  	  game_screen;
    unsigned char active_ship;
} Game;

void init_field(Cell** field);

Ship* create_ship(int type_ship);

void init_game(Game* settings);

void free_field(Cell** field);

void free_ships(Ship** ships);

void game_over(Game* settings);

int attack_ship(Game* settings,
		Cell* def_cell);

void kill_ship(Game* settings,
	       Ship* ship);

int place_ship(Cell** field,
	        Ship*  ship, 
	        Cell*  def_cell,
	        int    direction);

int is_free_space(Cell** field,
		  Ship*  def_ship,
		  Cell*  def_cell,
		  int    direction);

int filling_cells_vert(Cell** field,
		       Ship*  def_ship,
		       Cell*  def_cell);

int filling_cells_hor(Cell** field,
		      Ship*  def_ship,
		      Cell*  def_cell);

void log_err(int flag_error);

#endif

./io/io.h:
#ifndef IO_F
#define IO_F

#include "../../include/config.h"
#include "../game/game.h"

typedef struct {
    int x;
    int y;
    int on_field;
    int direction;
} Cursor;

void draw_border(int   starty, 
		 int   startx, 
		 int   height, 
		 int   width,
	   const char* label);

void draw_field(int 	starty, 
                int 	startx, 
                int 	is_own_field,     
                int     current_field,
                Cell**  field,
                Cursor* cursor,
                Ship*   active_ship);

void draw_buttons(int  starty, 
		  char mode);

void draw_transition_screen(Game* settings);

void draw_winner_screen(const char* winner_name);

void mv_up_cursor(Cursor* cursor);

void mv_down_cursor(Cursor* cursor);

void mv_left_cursor(Cursor* cursor);

void mv_right_cursor(Cursor* cursor);

void choose_ship_dir(Cursor* cursor);

void render_ui(int     starty, 
	       int     startx, 
	       int     height, 
	       int     width,
	       Game*   settings,
	       Cursor* cursor);

#endif

./io/io.c:
#include "io.h"

void draw_border(int   starty, 
		 int   startx, 
		 int   height, 
		 int   width,
	   const char* label) {
    mvaddch(starty, startx,             ACS_ULCORNER);
    mvhline(starty, startx + 1,         ACS_HLINE, width - 2);
    mvaddch(starty, startx + width - 1, ACS_URCORNER);

    mvvline(starty + 1, startx,             ACS_VLINE, height - 2);
    mvvline(starty + 1, startx + width - 1, ACS_VLINE, height - 2);

    mvaddch(starty + height - 1, startx,             ACS_LLCORNER);
    mvhline(starty + height - 1, startx + 1,         ACS_HLINE, width - 2);
    mvaddch(starty + height - 1, startx + width - 1, ACS_LRCORNER);

    if (label != NULL) {
        int label_length = strlen(label);
        int label_x = startx + (width - label_length) / 2;
        mvprintw(starty - 1, label_x, "%s", label);
    }
}

void draw_field(int 	starty, 
                int 	startx, 
                int 	is_own_field,     
                int 	current_field,
                Cell** 	field,
                Cursor* cursor,
                Ship* 	active_ship) {     
    for (int y = 0; y < FIELD_SIZE; y++) {
        for (int x = 0; x < FIELD_SIZE; x++) {
            int screen_y = starty + y;
            int screen_x = startx + x * 2;
            char ch = '~';
            switch (field[y][x].status) {
                case WATER: ch = '~'; break;
                case SHIP:  ch = is_own_field ? '#' : '~'; break;
                case HIT:   ch = '*'; break;
                case KILL:  ch = 'x'; break;
                case MISS:  ch = '^'; break;
            }

            int is_cursor_here = (cursor->x == x && 
                                  cursor->y == y && 
                                  cursor->on_field == current_field);

            int draw_preview = 0;
            if (is_own_field && 
                cursor->on_field == current_field && 
                active_ship != NULL && 
		!active_ship->is_placed) {
                    for (int i = 0; i < active_ship->length; i++) {
                        int px = cursor->x;
                        int py = cursor->y;

                        if (cursor->direction == VERT)
                            py -= i;
                        else
                            px += i;

                        if (px == x && py == y &&
                            px >= 0 && px < FIELD_SIZE &&
                            py >= 0 && py < FIELD_SIZE) {
                            draw_preview = 1;
                            break;
                        }
                    }
            }

            if (is_cursor_here) {
                attron(A_REVERSE);
                mvprintw(screen_y, screen_x, "%c", draw_preview ? '#' : ch);
                attroff(A_REVERSE);
            } else {
                mvprintw(screen_y, screen_x, "%c", draw_preview ? '#' : ch);
            }
        }
    }
}

void draw_buttons(int  starty, 
	    	  char mode) {
    char* mode_name; 
    if(mode == PLACEMENT_MODE)
	mode_name = "Расстановка кораблей";
    if(mode == BATTLE_MODE)
	mode_name = "Сражение";

    mvprintw(starty, 2, "[Режим: %s]", mode_name);
    mvprintw(starty + 1, 2, "Стрелки — перемещение");
    mvprintw(starty + 2, 2, "Enter — действие / установка");
    mvprintw(starty + 3, 2, "Ctrl+C — выход");
}

void draw_transition_screen(Game* settings) {
    int width = 40;
    int height = 5;
    int screen_width, screen_height;
    getmaxyx(stdscr, screen_height, screen_width); 

    int center_y = screen_height / 2 - height / 2;
    int center_x = screen_width / 2 - width / 2;

    for (int y = center_y; y < center_y + height; y++) {
        move(y, center_x);
        clrtoeol(); 
    }

    draw_border(center_y, center_x, height, width, "Смена хода");

    char* player_name = (settings->game_screen == PLAYER1_SCREEN) 
                      ? "Игрок 1" 
                      : "Игрок 2";

    mvprintw(center_y + height / 2, 
             center_x + (width - strlen(player_name) - 8) / 2,
             "%s, ваш ход!", player_name);

    mvprintw(center_y + height - 1, 
             center_x + (width - 27) / 2,
             "Нажмите Enter для продолжения");

    refresh(); 
}

void draw_winner_screen(const char* winner_name) {
    int width = 40;  
    int height = 5;  
    int screen_width, screen_height;
    
    getmaxyx(stdscr, screen_height, screen_width);
    
    int center_y = screen_height / 2 - height / 2;
    int center_x = screen_width / 2 - width / 2;
    
    for (int y = center_y; y < center_y + height; y++) {
        move(y, center_x);
        clrtoeol();
    }
    
    draw_border(center_y, center_x, height, width, "Игра окончена");
    
    mvprintw(center_y + height / 2, 
             center_x + (width - strlen(winner_name) - 12) / 2,
             "Победитель: %s!", winner_name);
    
    mvprintw(center_y + height - 1, 
             center_x + (width - 27) / 2,
             "Нажмите Enter для выхода");
    
    refresh();
}

void mv_up_cursor(Cursor* cursor) {
    if(cursor->y > 0)
	(cursor->y)--;
}

void mv_down_cursor(Cursor* cursor) {
    if(cursor->y < FIELD_SIZE - 1)
	(cursor->y)++;
}

void mv_left_cursor(Cursor* cursor) {
    if(cursor->x > 0)
	(cursor->x)--;
}

void mv_right_cursor(Cursor* cursor) {
    if(cursor->x < FIELD_SIZE - 1)
	(cursor->x)++;
}

void choose_ship_dir(Cursor* cursor) {
    cursor->direction = (cursor->direction == VERT) 
	      				    ?
	    				HOR : VERT;
}

void render_ui(int     starty, 
	       int     startx, 
	       int     height, 
	       int     width,
	       Game*   settings,
	       Cursor* cursor) {
        

	// Поля для первого игрока
        if(settings->game_screen == PLAYER1_SCREEN) {
            // Нарисовать рамку
            draw_border(starty, 
		    	startx, 
		    	height, 
		    	width,
			"Игрок 1");

	    draw_field(starty + 1, 
            	       startx + 2,  
		       SHOW_SHIPS,  
		       PLAYER_FIELD,
		       settings->p1_field,
		       cursor,
		       settings->p1_ships[settings->active_ship]);
                
            draw_field(starty + 1, 
            	       startx + FIELD_SIZE * CELL_WIDTH + 4, 
		       HIDE_SHIPS, 
		       ENEMY_FIELD,
		       settings->p2_field,	
		       cursor,
		       settings->p2_ships[settings->active_ship]);
	}

	// Поля для второго игрока
        if(settings->game_screen == PLAYER2_SCREEN) {
            // Нарисовать рамку
            draw_border(starty, 
		    	startx, 
		    	height, 
		    	width,
			"Игрок 2");

	    draw_field(starty + 1, 
            	       startx + 2, 
		       SHOW_SHIPS, 
            	       PLAYER_FIELD, 
            	       settings->p2_field,
		       cursor,
		       settings->p2_ships[settings->active_ship]); 
                
            draw_field(starty + 1, 
            	       startx + FIELD_SIZE * CELL_WIDTH + 4, 
		       HIDE_SHIPS, 
		       ENEMY_FIELD,
            	       settings->p1_field, 
		       cursor,
		       settings->p1_ships[settings->active_ship]);
	}
	

        // Кнопки
        draw_buttons(starty + height + 1, 
		     settings->game_mode);
}

./main.c:
#include "io.h"
#include "game.h"
#include "handler.h"

int main() {
    setlocale(LC_ALL, "");
    initscr();
    noecho();
    curs_set(FALSE);
    keypad(stdscr, TRUE);
    cbreak();

    // Позиции и размеры
    int field_box_y = 1, 
	field_box_x = 2;
    int field_box_height = FIELD_SIZE + 2;
    int field_box_width  = FIELD_SIZE * CELL_WIDTH * 2 + 6; 

    Game settings;
    init_game(&settings);

    Cursor cursor = { 0, 9, PLAYER_FIELD, VERT };

    while (settings.game_mode != GAME_OVER) {
	clear();
	
	render_ui(field_box_y,
	          field_box_x,
	          field_box_height,
	          field_box_width,
	          &settings,
	          &cursor);

	refresh();

	int key = getch();
	key_handler(key,
	            &cursor,
	            &settings);
	
	stage_handler(&settings,
		      &cursor);
    }

    game_over(&settings);

    endwin();

    return 0;
}

./handler/handler.c:
#include "handler.h"

KeyBinding bindings[] = {
    {PLACEMENT_MODE, KEY_UP,    mv_up_cursor},
    {PLACEMENT_MODE, KEY_DOWN,  mv_down_cursor},
    {PLACEMENT_MODE, KEY_LEFT,  mv_left_cursor},
    {PLACEMENT_MODE, KEY_RIGHT, mv_right_cursor},
    {PLACEMENT_MODE, '\t',      choose_ship_dir},
    {BATTLE_MODE,    KEY_UP,    mv_up_cursor},
    {BATTLE_MODE,    KEY_DOWN,  mv_down_cursor},
    {BATTLE_MODE,    KEY_LEFT,  mv_left_cursor},
    {BATTLE_MODE,    KEY_RIGHT, mv_right_cursor}
};

void key_handler(int     key,
		 Cursor* cursor, 
		 Game*   settings) {
    char break_flag = 0;
    int  bindings_size = sizeof(bindings) / sizeof(bindings[0]); 
    
    if(key == KEY_ENTER || key == '\n') {
	enter_handler(settings,
		      cursor);
	break_flag = 1;
    }
    for(int h_case = 0;
	    h_case < bindings_size && !break_flag;
            h_case++)
	if(bindings[h_case].mode == settings->game_mode && 
	   bindings[h_case].key  == key) {
	    bindings[h_case].handler(cursor);
	    break_flag = 1;
	}
}

void enter_handler(Game*    settings, 
		   Cursor*  cursor) {
    Cell** field;
    Ship*  ship;
   
    if(settings->game_screen == PLAYER1_SCREEN) {
	field = settings->p1_field;
	ship  = settings->p1_ships[settings->active_ship];
    } else {
	field = settings->p2_field;
	ship  = settings->p2_ships[settings->active_ship];
    }

    switch(settings->game_mode) {
	case PLACEMENT_MODE:
	    if (!ship->is_placed) {	        
		int result = place_ship(field,
		       	   		ship,
		           		&field[cursor->y][cursor->x],
		           		cursor->direction);
		if(result == SUCCESS) {
    		    ship->is_placed = true;
    		    if (settings->game_screen == PLAYER1_SCREEN) {
        		settings->count_p1_ships++;
    		    } else {
        		settings->count_p2_ships++;
    		    }
		}
	    }
	    break;
	case BATTLE_MODE:
	    if(settings->game_screen == PLAYER1_SCREEN)
		field = settings->p2_field;
    	    else
		field = settings->p1_field;
	    
	    int result = attack_ship(settings,
			             &field[cursor->y][cursor->x]);
	    if(result == SUCCESS) {	
		settings->game_screen = 
			(settings->game_screen == PLAYER1_SCREEN) 
		    	? PLAYER2_SCREEN 
		    	: PLAYER1_SCREEN;

		clear();
		draw_transition_screen(settings);
		refresh();
		
		while(getch() != '\n');
	    }
	    
	    
	    break;
	default:
	    break;
    }
}

void stage_handler(Game*   settings,
		   Cursor* cursor) {
    // Переключение на следующий корабль после размещения
    Ship** ships = (settings->game_screen == PLAYER1_SCREEN) ? 
	            settings->p1_ships : 
		    settings->p2_ships;

    if(settings->game_mode == PLACEMENT_MODE && 
    	ships[settings->active_ship]->is_placed)
	settings->active_ship++;
    
    if(settings->active_ship >= COUNT_SHIPS) {
        if(settings->game_screen == PLAYER1_SCREEN)
	   settings->game_screen = PLAYER2_SCREEN;
	else { 
	    settings->game_screen = PLAYER1_SCREEN;
	    settings->game_mode   = BATTLE_MODE;

	    clear();
	    draw_transition_screen(settings);
	    refresh();
	    
	    while(getch() != '\n');

	    cursor->on_field = ENEMY_FIELD;
            cursor->x = 0;
            cursor->y = 0;
	}
	settings->active_ship = 0;
    }

    if (settings->game_mode == BATTLE_MODE) {
        if (settings->count_p1_ships == 0) {
            settings->game_mode = GAME_OVER;
            
	    clear();
	    draw_winner_screen("Игрок 2");
	    refresh();
	    
	    while(getch() != '\n');
    	} 
        else if (settings->count_p2_ships == 0) {
            settings->game_mode = GAME_OVER;
            
	    clear();
	    draw_winner_screen("Игрок 1");
	    refresh();
	    
	    while(getch() != '\n');
        }
    }
}

./handler/handler.h:
#ifndef HANDLER_H
#define HANDLER_H

#include "../../include/config.h"
#include "../io/io.h"
#include "../game/game.h"

typedef void (*KeyHandler)(Cursor*);

typedef struct {
    char       mode;
    int        key;
    KeyHandler handler;
} KeyBinding;

extern KeyBinding bindings[];

void key_handler(int  	 key,
		 Cursor* cursor, 
		 Game*   settings);

void enter_handler(Game*   settings, 
		   Cursor* cursor);

void stage_handler(Game*   settings,
		   Cursor* cursor);

#endif

