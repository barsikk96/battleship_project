./game/game.c:
#include "game.h"

void init_field(Cell** field) {
    for(unsigned char init_row = 0; init_row < 10; init_row++)
	for(unsigned char init_col = 0; 
			  init_col < 10; 
			  init_col++) {
	    field[init_row][init_col].row     = init_row;
	    field[init_row][init_col].col     = init_col;
	    field[init_row][init_col].ship    = NULL;
	    field[init_row][init_col].status  = WATER;
	}
}

Ship* create_ship(int type_ship) {
    int flag_error = SUCCESS;

    Ship* ship = malloc(sizeof(Ship));
    if(!ship) {
	flag_error = ERR_ALLOCATION;
	log_err(flag_error);
    }

    if(!flag_error) {
	switch(type_ship) {
	    case BATTLESHIP:
		ship->length = 4;
		ship->hp     = 4;
		break;
	    case CRUISER:
		ship->length = 3;
		ship->hp     = 3;
		break;
	    case DESTROYER:
		ship->length = 2;
		ship->hp     = 2;
		break;
	    case BOAT:
		ship->length = 1;
		ship->hp     = 1;
		break;
	}
    }

    return ship;
}

void init_game(Game* settings) {
    settings->p1_field = malloc(FIELD_SIZE * sizeof(Cell*));
    for (int i = 0; i < FIELD_SIZE; i++)
    	settings->p1_field[i] = malloc(FIELD_SIZE * sizeof(Cell));
    init_field(settings->p1_field);

    settings->p2_field = malloc(FIELD_SIZE * sizeof(Cell*));
    for (int i = 0; i < FIELD_SIZE; i++)
    	settings->p2_field[i] = malloc(FIELD_SIZE * sizeof(Cell));
    init_field(settings->p2_field);

    settings->count_p1_ships  = 0;  
    settings->p1_ships = malloc(COUNT_SHIPS * sizeof(Ship*));
    
    settings->count_p2_ships  = 0;
    settings->p2_ships = malloc(COUNT_SHIPS * sizeof(Ship*));

    size_t count     = 0;
    int    type_ship = BATTLESHIP;
    while(count < COUNT_SHIPS) {
	for(int count_type = 0; 
		   count_type < type_ship; 
		   count_type++) {
	    settings->p1_ships[count] = create_ship(type_ship);
	    settings->p2_ships[count] = create_ship(type_ship);
	    settings->p1_ships[count]->is_placed = false;
	    settings->p2_ships[count]->is_placed = false;
	    count++;
	}
	type_ship++;
    }

    settings->game_mode   = PLACEMENT_MODE;
    settings->game_screen = PLAYER1_SCREEN;
}

void game_over(Game* settings) {
    if(settings->p1_field) {
	free(settings->p1_field);
	settings->p1_field = NULL;
    }
    if(settings->p2_field) {
        free(settings->p2_field);
        settings->p2_field = NULL;
    }

    // Освобождаем корабли игрока 1
    if (settings->p1_ships) {
        for (unsigned char i = 0; i < settings->count_p1_ships; i++) {
            if (settings->p1_ships[i]) {
                free(settings->p1_ships[i]);
		settings->p1_ships[i] = NULL;
            }
        }
        free(settings->p1_ships); 
        settings->p1_ships = NULL;
    }

    // Освобождаем корабли игрока 2 
    if (settings->p2_ships) {
        for (unsigned char i = 0; i < settings->count_p2_ships; i++) {
            if (settings->p2_ships[i]) {
                free(settings->p2_ships[i]);  
                settings->p2_ships[i] = NULL;
            }
        }
        free(settings->p2_ships);  
        settings->p2_ships = NULL;
    }

    settings->count_p1_ships = 0;
    settings->count_p2_ships = 0;
}

void place_ship(Cell** field,
	        Ship*  ship, 
	        Cell*  def_cell,
	        int    direction) {
    int flag_error = SUCCESS;
    
    switch(direction) {
	case VERT:
	    flag_error = filling_cells_vert(field, 
			    	 	    ship, 
					    def_cell);
	    log_err(flag_error);
	    break;
	case HOR:
	    flag_error = filling_cells_hor(field, 
			      		   ship, 
			      	 	   def_cell);
	    log_err(flag_error);
	    break;
	default:
	    break;
    }
}

int is_free_space(Cell** field,
		  Ship*  def_ship,
		  Cell*  def_cell,
		  int    direction) {
    int flag_error = SUCCESS;

    unsigned char count_len = def_ship->length;
    
    if(direction == VERT) {
    	if(count_len <= 
           def_cell->row + 1) {
	    for(int row = def_cell->row; 
		count_len > 0;
		row--) {
	        if(field[row][def_cell->col].ship)
	    	    flag_error = ERR_OCC_CELL;
	    	
		count_len--;
	    }
	} else
	    flag_error = ERR_NO_SPACE;
    }
    if(direction == HOR) {
	if(count_len <= 
       	   10 - def_cell->col) {
	    for(int col = def_cell->col; 
		count_len > 0;
		col++) {
	    	if(field[def_cell->row][col].ship)
	    	    flag_error = ERR_OCC_CELL;
		
		count_len--;
	    }
	} else
	    flag_error = ERR_NO_SPACE;
    }

    return flag_error;
}

int filling_cells_vert(Cell** field,
		       Ship*  def_ship,
		       Cell*  def_cell) {
    int flag_error = SUCCESS;

    
    unsigned char count_len = def_ship->length;
    
    flag_error = is_free_space(field,
		      	       def_ship,
		      	       def_cell,
		      	       VERT);
    for(int row = def_cell->row; 
	    count_len > 0 && !flag_error; 
            row--) {
	field[row][def_cell->col].ship   = def_ship;
	field[row][def_cell->col].status = SHIP; 
	count_len--;
    } 

    return flag_error;
}

int filling_cells_hor(Cell** field,
		      Ship*  def_ship,
		      Cell*  def_cell) {
    int flag_error = SUCCESS;

    unsigned char count_len = def_ship->length;
    
    flag_error = is_free_space(field,
		      	       def_ship,
		      	       def_cell,
		      	       HOR);
    for(int col = def_cell->col; 
	    count_len > 0 && !flag_error;
	    col++) {
	field[def_cell->row][col].ship   = def_ship;
	field[def_cell->row][col].status = SHIP;
	count_len--;
    } 

    return flag_error;
}

void log_err(int flag_error) {
    FILE* log_file = fopen("../log_file.txt", "a");
    
    
    time_t current_time = time(NULL);
    struct tm *time_info;
    char   time_str[100];
    time_info = localtime(&current_time);
    strftime(time_str, 
	     sizeof(time_str), 
	     "%Y-%m-%d %H:%M:%S", time_info);

    if(!log_file) {
	flag_error = ERR_ALLOCATION;
    	printf("Ошибка открытия файла! - %s\n", time_str);
    } else {
    	switch(flag_error) {
	    case ERR_ALLOCATION:
	    	fprintf(log_file, 
		        "Ошибка выделения памяти! - %s\n",  time_str);
	    	break;
	    case ERR_NO_SPACE:
	    	fprintf(log_file, 
		        "Выход за пределы массива! - %s\n", time_str);
	    	break;
	    case ERR_OCC_CELL:
	    	fprintf(log_file, 
		        "Клетка занята! - %s\n", 	    time_str);
	    	break;
	    default:
	    	break;
    	}
    }

    fclose(log_file);
}

./game/game.h:
#ifndef GAME_H
#define GAME_H

#include "../include/config.h"

typedef struct {
    unsigned char length;
    unsigned char hp;
    bool 	  is_placed;
} Ship;

typedef struct {
    Ship* 	  ship;
    unsigned char row;
    unsigned char col;
    	     char status;
} Cell;

typedef struct {
    Cell**        p1_field;
    Cell**	  p2_field;
    Ship** 		p1_ships;
    unsigned char count_p1_ships;
    Ship** 		p2_ships;
    unsigned char count_p2_ships;
    char   	  game_mode;
    char  	  game_screen;
} Game;

void init_field(Cell** field);

Ship* create_ship(int type_ship);

void init_game(Game* settings);

void game_over(Game* settings);

void place_ship(Cell** field,
	        Ship*  ship, 
	        Cell*  def_cell,
	        int    direction);

int is_free_space(Cell** field,
		  Ship*  def_ship,
		  Cell*  def_cell,
		  int    direction);

int filling_cells_vert(Cell** field,
		       Ship*  def_ship,
		       Cell*  def_cell);

int filling_cells_hor(Cell** field,
		      Ship*  def_ship,
		      Cell*  def_cell);

void log_err(int flag_error);

#endif

./io/io.h:
#ifndef IO_F
#define IO_F

#include "../../include/config.h"
#include "../game/game.h"

typedef struct {
    int x;
    int y;
    int on_field;
    int direction;
} Cursor;

void draw_border(int starty, 
		 int startx, 
		 int height, 
		 int width);

void draw_field(int 	starty, 
                int 	startx, 
                int 	is_own_field,     
                int     current_field,
                Cell**  field,
                Cursor* cursor,
                Ship*   active_ship,
                Game*   settings);

void draw_buttons(int  starty, 
		  char mode);

void mv_up_cursor(Cursor* cursor);

void mv_down_cursor(Cursor* cursor);

void mv_left_cursor(Cursor* cursor);

void mv_right_cursor(Cursor* cursor);

void mv_field_cursor(Cursor* cursor);

void choose_ship_dir(Cursor* cursor);

void render_ui(int     starty, 
	       int     startx, 
	       int     height, 
	       int     width,
	       Game*   settings,
	       Cursor* cursor,
	       size_t  active_ship);

#endif

./io/io.c:
#include "io.h"

void draw_border(int starty, 
		 int startx, 
		 int height, 
		 int width) {
    mvaddch(starty, startx,             ACS_ULCORNER);
    mvhline(starty, startx + 1,         ACS_HLINE, width - 2);
    mvaddch(starty, startx + width - 1, ACS_URCORNER);

    mvvline(starty + 1, startx,             ACS_VLINE, height - 2);
    mvvline(starty + 1, startx + width - 1, ACS_VLINE, height - 2);

    mvaddch(starty + height - 1, startx,             ACS_LLCORNER);
    mvhline(starty + height - 1, startx + 1,         ACS_HLINE, width - 2);
    mvaddch(starty + height - 1, startx + width - 1, ACS_LRCORNER);
}

void draw_field(int starty, 
                int startx, 
                int is_own_field,     
                int current_field,
                Cell** field,
                Cursor* cursor,
                Ship* active_ship,    // Изменили на указатель
                Game* settings) {     // Добавили для доступа к счетчикам
    for (int y = 0; y < FIELD_SIZE; y++) {
        for (int x = 0; x < FIELD_SIZE; x++) {
            int screen_y = starty + y;
            int screen_x = startx + x * 2;
            char ch = '~';
            switch (field[y][x].status) {
                case WATER: ch = '~'; break;
                case SHIP:  ch = is_own_field ? '#' : '~'; break;
                case HIT:   ch = '*'; break;
                case KILL:  ch = 'x'; break;
                case MISS:  ch = '^'; break;
            }

            int is_cursor_here = (cursor->x == x && 
                                  cursor->y == y && 
                                  cursor->on_field == current_field);

            int draw_preview = 0;
            if (is_own_field && 
                cursor->on_field == current_field && 
                active_ship != NULL && 
		!active_ship->is_placed) {
                // Проверяем, что корабль ещё не размещён
                int is_ship_not_placed = (settings->game_screen == PLAYER1_SCREEN) ?
                    (settings->count_p1_ships <= active_ship->length) :
                    (settings->count_p2_ships <= active_ship->length);

                if (is_ship_not_placed) {
                    for (int i = 0; i < active_ship->length; i++) {
                        int px = cursor->x;
                        int py = cursor->y;

                        if (cursor->direction == VERT)
                            py -= i;
                        else
                            px += i;

                        if (px == x && py == y &&
                            px >= 0 && px < FIELD_SIZE &&
                            py >= 0 && py < FIELD_SIZE) {
                            draw_preview = 1;
                            break;
                        }
                    }
                }
            }

            if (is_cursor_here) {
                attron(A_REVERSE);
                mvprintw(screen_y, screen_x, "%c", draw_preview ? '#' : ch);
                attroff(A_REVERSE);
            } else {
                mvprintw(screen_y, screen_x, "%c", draw_preview ? '#' : ch);
            }
        }
    }
}

void draw_buttons(int  starty, 
	    	  char mode) {
    char* mode_name; 
    if(mode == PLACEMENT_MODE)
	mode_name = "Расстановка кораблей";
    if(mode == BATTLE_MODE)
	mode_name = "Сражение";

    mvprintw(starty, 2, "[Режим: %s]", mode_name);
    mvprintw(starty + 1, 2, "Стрелки — перемещение");
    mvprintw(starty + 2, 2, "Enter — действие / установка");
    mvprintw(starty + 3, 2, "Ctrl+C — выход");
}

void mv_up_cursor(Cursor* cursor) {
    if(cursor->y > 0)
	(cursor->y)--;
}

void mv_down_cursor(Cursor* cursor) {
    if(cursor->y < FIELD_SIZE - 1)
	(cursor->y)++;
}

void mv_left_cursor(Cursor* cursor) {
    if(cursor->x > 0)
	(cursor->x)--;
}

void mv_right_cursor(Cursor* cursor) {
    if(cursor->x < FIELD_SIZE - 1)
	(cursor->x)++;
}

void mv_field_cursor(Cursor* cursor) {
    cursor->on_field = (cursor->on_field == PLAYER_FIELD) 
	    				  ? 
	    		      ENEMY_FIELD : PLAYER_FIELD;
}

void choose_ship_dir(Cursor* cursor) {
    cursor->direction = (cursor->direction == VERT) 
	      				    ?
	    				HOR : VERT;
}

void render_ui(int     starty, 
	       int     startx, 
	       int     height, 
	       int     width,
	       Game*   settings,
	       Cursor* cursor,
	       size_t  active_ship) {
        // Нарисовать рамку
        draw_border(starty, 
		    startx, 
		    height, 
		    width);

	// Поля для первого игрока
        if(settings->game_screen == PLAYER1_SCREEN) {
            draw_field(starty + 1, 
            	       startx + 2,  
		       SHOW_SHIPS,  
		       PLAYER_FIELD,
		       settings->p1_field,
		       cursor,
		       settings->p1_ships[active_ship],
		       settings);
                
            draw_field(starty + 1, 
            	       startx + FIELD_SIZE * CELL_WIDTH + 4, 
		       HIDE_SHIPS, 
		       ENEMY_FIELD,
		       settings->p2_field,	
		       cursor,
		       settings->p2_ships[active_ship],
		       settings);
	}

	// Поля для второго игрока
        if(settings->game_screen == PLAYER2_SCREEN) {
            draw_field(starty + 1, 
            	       startx + 2, 
		       SHOW_SHIPS, 
            	       PLAYER_FIELD, 
            	       settings->p2_field,
		       cursor,
		       settings->p2_ships[active_ship],
		       settings); 
                
            draw_field(starty + 1, 
            	       startx + FIELD_SIZE * CELL_WIDTH + 4, 
		       HIDE_SHIPS, 
		       ENEMY_FIELD,
            	       settings->p1_field, 
		       cursor,
		       settings->p1_ships[active_ship],
		       settings);
	}
	

        // Кнопки
        draw_buttons(starty + height + 1, 
		     settings->game_mode);
}

./main.c:
#include "io.h"
#include "game.h"
#include "handler.h"

int main() {
    setlocale(LC_ALL, "");
    initscr();
    noecho();
    curs_set(FALSE);
    keypad(stdscr, TRUE);
    cbreak();

    int screen_height, 
	screen_width;
    getmaxyx(stdscr, screen_height, screen_width);

    // Позиции и размеры
    int field_box_y = 1, 
	field_box_x = 2;
    int field_box_height = FIELD_SIZE + 2;
    int field_box_width  = FIELD_SIZE * CELL_WIDTH * 2 + 6; 

    Game settings;
    init_game(&settings);

    Cursor cursor = { 0, 9, PLAYER_FIELD, VERT };

    size_t active_ship = 0;
    while (1) {
	clear();
	
	render_ui(field_box_y,
	          field_box_x,
	          field_box_height,
	          field_box_width,
	          &settings,
	          &cursor,
	          active_ship);

	refresh();

	int key = getch();
	handle_cases(key,
	             &cursor,
	             active_ship,
	             &settings);
	
	// Переключение на следующий корабль после размещения
	if (settings.game_mode == PLACEMENT_MODE && 
	    (settings.count_p1_ships > active_ship || 
	     settings.count_p2_ships > active_ship)) {
	    active_ship++;
	    if (active_ship >= COUNT_SHIPS) {
	        // Все корабли размещены
	        settings.game_mode = BATTLE_MODE;
	    }
	}
    }
    
    game_over(&settings);

    endwin();

    return 0;
}

./handler/handler.c:
#include "handler.h"

KeyBinding bindings[] = {
    {PLACEMENT_MODE, KEY_UP,    mv_up_cursor},
    {PLACEMENT_MODE, KEY_DOWN,  mv_down_cursor},
    {PLACEMENT_MODE, KEY_LEFT,  mv_left_cursor},
    {PLACEMENT_MODE, KEY_RIGHT, mv_right_cursor},
    {PLACEMENT_MODE, '\t',      choose_ship_dir},
    {BATTLE_MODE,    KEY_UP,    mv_up_cursor},
    {BATTLE_MODE,    KEY_DOWN,  mv_down_cursor},
    {BATTLE_MODE,    KEY_LEFT,  mv_left_cursor},
    {BATTLE_MODE,    KEY_RIGHT, mv_right_cursor},
    {BATTLE_MODE,    '\t',      mv_field_cursor}
};

void handle_cases(int     key,
		  Cursor* cursor,
		  size_t  ship, 
		  Game*   settings) {
    char break_flag = 0;
    int  bindings_size = sizeof(bindings) / sizeof(bindings[0]); 
    
    if(key == KEY_ENTER || key == '\n') {
	enter_handler(settings,
		      ship,
		      cursor);
	break_flag = 1;
    }
    for(int h_case = 0;
	    h_case < bindings_size && !break_flag;
            h_case++)
	if(bindings[h_case].mode == settings->game_mode && 
	   bindings[h_case].key  == key) {
	    bindings[h_case].handler(cursor);
	    break_flag = 1;
	}
}

void enter_handler(Game*    settings,
		   size_t   num_ship, 
		   Cursor*  cursor) {
    Cell** field;
    Ship*  ship;
    if(settings->game_screen == PLAYER1_SCREEN) {
	field = settings->p1_field;
	ship  = settings->p1_ships[num_ship];
    	settings->count_p1_ships++;
    } else {
	field = settings->p2_field;
	ship  = settings->p2_ships[num_ship];
	settings->count_p2_ships++;
    }

    switch(settings->game_mode) {
	case PLACEMENT_MODE:
	    if ((settings->game_screen == PLAYER1_SCREEN && 
         	num_ship >= settings->count_p1_ships) ||
        	(settings->game_screen == PLAYER2_SCREEN && 
         	num_ship >= settings->count_p2_ships)) 
	        place_ship(field,
		       	   ship,
		           &field[cursor->y][cursor->x],
		           cursor->direction);
	    break;
	case BATTLE_MODE:
	    /*attack_ship(создать функцию атаки корабля);*/
	    break;
	default:
	    break;
    }
}

./handler/handler.h:
#ifndef HANDLER_H
#define HANDLER_H

#include "../../include/config.h"
#include "../io/io.h"
#include "../game/game.h"

typedef void (*KeyHandler)(Cursor*);

typedef struct {
    char       mode;
    int        key;
    KeyHandler handler;
} KeyBinding;

extern KeyBinding bindings[];

void handle_cases(int  	  key,
		  Cursor* cursor,
		  size_t  ship, //временное решение
		  Game*   settings);

void enter_handler(Game*   settings,
		   size_t  ship, /*ship в составе структуры надо сделать*/
		   Cursor* cursor);

#endif

